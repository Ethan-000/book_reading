//! Sumcheck Protocol for multilinear extension

use crate::sumcheck::polynomial_rep::{PolynomialRep, PolyInfoForVerifier};
use crate::sumcheck::protocol::prover::ProverMsg;
use crate::sumcheck::protocol::IPForSumCheck;


use crate::rng::{Blake2s512Rng, FeedableRNG};
use ark_ff::Field;

#[allow(dead_code)]
use ark_std::marker::PhantomData;
use ark_std::vec::Vec;

pub mod protocol;

pub mod polynomial_rep;
#[cfg(test)]
mod test;

/// Sumcheck for products of multilinear polynomial
pub struct SumSheck<F: Field>(#[doc(hidden)] PhantomData<F>);

/// proof generated by prover
pub type Proof<F> = Vec<ProverMsg<F>>;

impl<F: Field> SumSheck<F> {

    pub fn prove(polynomial: &PolynomialRep<F>) -> Result<Proof<F>, crate::Error> {
        let mut fs_rng = Blake2s512Rng::setup();
        fs_rng.feed(&polynomial.info_for_verifier())?;

        let mut prover_state = IPForSumCheck::prover_init(&polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.num_of_variables);
        for _ in 0..polynomial.num_of_variables {
            let (prover_msg, prover_state_new) =
                IPForSumCheck::prove_round(prover_state, &verifier_msg);
            prover_state = prover_state_new;
            fs_rng.feed(&prover_msg)?;
            prover_msgs.push(prover_msg);
            verifier_msg = Some(IPForSumCheck::generate_message(&mut fs_rng));
        }

        Ok(prover_msgs)
    }

    /// verify the claimed sum using the proof
    pub fn verify(
        polynomial_info: &PolyInfoForVerifier,
        claimed_sum: F,
        proof: &Proof<F>,
    ) -> Result<bool, crate::Error> {
        let mut fs_rng = Blake2s512Rng::setup();
        fs_rng.feed(polynomial_info)?;
        let mut verifier_state = IPForSumCheck::verifier_init(polynomial_info);
        for i in 0..polynomial_info.num_of_variables {
            let prover_msg = proof.get(i).expect("proof is incomplete");
            fs_rng.feed(prover_msg)?;
            let result =
                IPForSumCheck::verify_round(verifier_state, (*prover_msg).clone(), &mut fs_rng);
            verifier_state = result.1;
        }

        Ok(IPForSumCheck::acceptance(
            verifier_state,
            claimed_sum,
        )?)
    }
}
